# app/core/logging_config.py
"""Centralized logging configuration for Ollama Proxy Server.

Features:
--------
* Human-readable console output by default (with proper millisecond timestamps).
* Optional JSON output via LOG_FORMAT env-var (kept for backward-compatibility).
* All loggers (root, uvicorn, gunicorn, etc.) share the same configuration.
* The `setup_logging()` helper can be called from any entry-point (FastAPI,
  management scripts, tests) to guarantee a consistent format.
"""

import logging
import logging.config
import os

from pythonjsonlogger import jsonlogger


# ----------------------------------------------------------------------
# Human‑readable formatter
# ----------------------------------------------------------------------
class HumanReadableFormatter(logging.Formatter):
    """Formatter for the human readable logs.

    Example output (note the millisecond precision):
    2025-09-05 15:35:22,123 [INFO] gunicorn.error – Starting gunicorn 23.0.0.
    """

    # %(asctime)s is generated by the base Formatter; we append milliseconds via %(msecs)03d
    DEFAULT_FORMAT = "%(asctime)s,%(msecs)03d [%(levelname)s] %(name)s – %(message)s"
    DEFAULT_DATEFMT = "%Y-%m-%d %H:%M:%S"  # No %f here - we add ms ourselves

    def __init__(self):
        """Initialize the formatter with default format and date format."""
        super().__init__(self.DEFAULT_FORMAT, self.DEFAULT_DATEFMT)


# ----------------------------------------------------------------------
# JSON formatter – kept for compatibility
# ----------------------------------------------------------------------
class JsonFormatter(jsonlogger.JsonFormatter):
    """Emit JSON logs similar to the original configuration."""

    def add_fields(self, log_record, record, message_dict):
        """Add custom fields to the log record."""
        super().add_fields(log_record, record, message_dict)
        # Preserve a float epoch timestamp like the previous version
        if not log_record.get("timestamp"):
            log_record["timestamp"] = record.created
        # Normalise level name to upper‑case
        log_record["level"] = (log_record.get("level") or record.levelname).upper()


# ----------------------------------------------------------------------
# Build the dictConfig – selects formatter based on LOG_FORMAT env‑var
# ----------------------------------------------------------------------
def _build_logging_config(log_level: str = "INFO") -> dict:
    """Return dict compatible with logging.config.dictConfig.

    Args:
        log_level: Standard logging level name (case-insensitive).
    """
    level = log_level.upper()

    # Choose which formatter to use (human-readable is default)
    fmt_type = os.getenv("LOG_FORMAT", "human").lower()
    if fmt_type == "json":
        formatter_name = "json"
        formatter_cfg = {
            "()": "app.core.logging_config.JsonFormatter",
            "format": "%(timestamp)s %(level)s %(name)s %(module)s %(funcName)s %(lineno)d %(message)s",
        }
    else:  # human-readable
        formatter_name = "human"
        formatter_cfg = {"()": "app.core.logging_config.HumanReadableFormatter"}

    return {
        "version": 1,
        "disable_existing_loggers": False,
        "formatters": {
            "human": formatter_cfg,
            "json": formatter_cfg,
        },
        "handlers": {
            "default": {
                "class": "logging.StreamHandler",
                "formatter": formatter_name,
                "stream": "ext://sys.stdout",
            },
        },
        # ------------------------------------------------------------------
        # Root logger (required - this was missing before)
        "root": {
            "level": level,
            "handlers": ["default"],
        },
        # ------------------------------------------------------------------
        # Specific library loggers (prevent duplicate handlers)
        # ------------------------------------------------------------------
        "loggers": {
            "uvicorn.error": {"handlers": ["default"], "level": level, "propagate": False},
            "uvicorn.access": {"handlers": ["default"], "level": level, "propagate": False},
            "gunicorn.error": {"handlers": ["default"], "level": level, "propagate": False},
            "gunicorn.access": {"handlers": ["default"], "level": level, "propagate": False},
        },
    }


# ----------------------------------------------------------------------
# Public objects used by the rest of the codebase
# ----------------------------------------------------------------------
# Default config imported by gunicorn_conf.py
LOGGING_CONFIG = _build_logging_config()


def setup_logging(log_level: str = "INFO") -> None:
    """Apply the logging configuration.

    It can be called multiple times; each call simply re-applies the dict configuration.
    """
    config = _build_logging_config(log_level)
    logging.config.dictConfig(config)


# Exported names for from app.core.logging_config import
__all__ = ["setup_logging", "LOGGING_CONFIG", "HumanReadableFormatter", "JsonFormatter"]
